% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/statement_execution.R
\docType{data}
\name{statement_execution}
\alias{statement_execution}
\title{The SQL Statement Execution API manages the execution of arbitrary SQL
statements and the fetching of result data.}
\format{
An object of class \code{list} of length 4.
}
\usage{
statement_execution
}
\description{
\strong{Release status}
}
\details{
This feature is in \href{https://docs.databricks.com/release-notes/release-types.html}{Public Preview}.

\strong{Getting started}

We suggest beginning with the \href{https://docs.databricks.com/sql/api/sql-execution-tutorial.html}{SQL Statement Execution API tutorial}.

\strong{Overview of statement execution and result fetching}

Statement execution begins by issuing a
:method:statementexecution/executeStatement request with a valid SQL
statement and warehouse ID, along with optional parameters such as the data
catalog and output format.

When submitting the statement, the call can behave synchronously or
asynchronously, based on the \code{wait_timeout} setting. When set between 5-50
seconds (default: 10) the call behaves synchronously and waits for results up
to the specified timeout; when set to \verb{0s}, the call is asynchronous and
responds immediately with a statement ID that can be used to poll for status
or fetch the results in a separate call.

\strong{Call mode: synchronous}

In synchronous mode, when statement execution completes within the \verb{wait timeout}, the result data is returned directly in the response. This response
will contain \code{statement_id}, \code{status}, \code{manifest}, and \code{result} fields. The
\code{status} field confirms success whereas the \code{manifest} field contains the
result data column schema and metadata about the result set. The \code{result}
field contains the first chunk of result data according to the specified
\code{disposition}, and links to fetch any remaining chunks.

If the execution does not complete before \code{wait_timeout}, the setting
\code{on_wait_timeout} determines how the system responds.

By default, \code{on_wait_timeout=CONTINUE}, and after reaching \code{wait_timeout}, a
response is returned and statement execution continues asynchronously. The
response will contain only \code{statement_id} and \code{status} fields, and the caller
must now follow the flow described for asynchronous call mode to poll and
fetch the result.

Alternatively, \code{on_wait_timeout} can also be set to \code{CANCEL}; in this case if
the timeout is reached before execution completes, the underlying statement
execution is canceled, and a \code{CANCELED} status is returned in the response.

\strong{Call mode: asynchronous}

In asynchronous mode, or after a timed-out synchronous request continues, a
\code{statement_id} and \code{status} will be returned. In this case polling
:method:statementexecution/getStatement calls are required to fetch the
result and metadata.

Next, a caller must poll until execution completes (\code{SUCCEEDED}, \code{FAILED},
etc.) by issuing :method:statementexecution/getStatement requests for the
given \code{statement_id}.

When execution has succeeded, the response will contain \code{status}, \code{manifest},
and \code{result} fields. These fields and the structure are identical to those in
the response to a successful synchronous submission. The \code{result} field will
contain the first chunk of result data, either \code{INLINE} or as
\code{EXTERNAL_LINKS} depending on \code{disposition}. Additional chunks of result data
can be fetched by checking for the presence of the \code{next_chunk_internal_link}
field, and iteratively \code{GET} those paths until that field is unset: \verb{GET https://$DATABRICKS_HOST/\{next_chunk_internal_link\}}.

\strong{Fetching result data: format and disposition}

To specify the result data format, set the \code{format} field to \code{JSON_ARRAY}
(JSON), \code{ARROW_STREAM} (\href{https://arrow.apache.org/overview/}{Apache Arrow Columnar}), or \code{CSV}.

You can also configure how to fetch the result data in two different modes by
setting the \code{disposition} field to \code{INLINE} or \code{EXTERNAL_LINKS}.

The \code{INLINE} disposition can only be used with the \code{JSON_ARRAY} format and
allows results up to 16 MiB. When a statement executed with \code{INLINE}
disposition exceeds this limit, the execution is aborted, and no result can
be fetched.

The \code{EXTERNAL_LINKS} disposition allows fetching large result sets in
\code{JSON_ARRAY}, \code{ARROW_STREAM} and \code{CSV} formats, and with higher throughput.

The API uses defaults of \code{format=JSON_ARRAY} and \code{disposition=INLINE}.
Databricks recommends that you explicit setting the format and the
disposition for all production use cases.

\strong{Statement response: statement_id, status, manifest, and result}

The base call :method:statementexecution/getStatement returns a single
response combining \code{statement_id}, \code{status}, a result \code{manifest}, and a
\code{result} data chunk or link, depending on the \code{disposition}. The \code{manifest}
contains the result schema definition and the result summary metadata. When
using \code{disposition=EXTERNAL_LINKS}, it also contains a full listing of all
chunks and their summary metadata.

\strong{Use case: small result sets with INLINE + JSON_ARRAY}

For flows that generate small and predictable result sets (<= 16 MiB),
\code{INLINE} downloads of \code{JSON_ARRAY} result data are typically the simplest way
to execute and fetch result data.

When the result set with \code{disposition=INLINE} is larger, the result can be
transferred in chunks. After receiving the initial chunk with
:method:statementexecution/executeStatement or
:method:statementexecution/getStatement subsequent calls are required to
iteratively fetch each chunk. Each result response contains a link to the
next chunk, when there are additional chunks to fetch; it can be found in the
field \code{.next_chunk_internal_link}. This link is an absolute \code{path} to be
joined with your \verb{$DATABRICKS_HOST}, and of the form
\verb{/api/2.0/sql/statements/\{statement_id\}/result/chunks/\{chunk_index\}}. The
next chunk can be fetched by issuing a
:method:statementexecution/getStatementResultChunkN request.

When using this mode, each chunk may be fetched once, and in order. A chunk
without a field \code{next_chunk_internal_link} indicates the last chunk was
reached and all chunks have been fetched from the result set.

\strong{Use case: large result sets with EXTERNAL_LINKS + ARROW_STREAM}

Using \code{EXTERNAL_LINKS} to fetch result data in Arrow format allows you to
fetch large result sets efficiently. The primary difference from using
\code{INLINE} disposition is that fetched result chunks contain resolved
\code{external_links} URLs, which can be fetched with standard HTTP.

\strong{Presigned URLs}

External links point to data stored within your workspace's internal DBFS, in
the form of a presigned URL. The URLs are valid for only a short period, <=
15 minutes. Alongside each \code{external_link} is an expiration field indicating
the time at which the URL is no longer valid. In \code{EXTERNAL_LINKS} mode,
chunks can be resolved and fetched multiple times and in parallel.
\subsection{\strong{Warning: We recommend you protect the URLs in the EXTERNAL_LINKS.}}{

When using the EXTERNAL_LINKS disposition, a short-lived pre-signed URL is
generated, which the client can use to download the result chunk directly
from cloud storage. As the short-lived credential is embedded in a pre-signed
URL, this URL should be protected.

Since pre-signed URLs are generated with embedded temporary credentials, you
need to remove the authorization header from the fetch requests.

Similar to \code{INLINE} mode, callers can iterate through the result set, by
using the \code{next_chunk_internal_link} field. Each internal link response will
contain an external link to the raw chunk data, and additionally contain the
\code{next_chunk_internal_link} if there are more chunks.

Unlike \code{INLINE} mode, when using \code{EXTERNAL_LINKS}, chunks may be fetched out
of order, and in parallel to achieve higher throughput.

\strong{Limits and limitations}

Note: All byte limits are calculated based on internal storage metrics and
will not match byte counts of actual payloads.
\itemize{
\item Statements with \code{disposition=INLINE} are limited to 16 MiB and will abort
when this limit is exceeded. - Statements with \code{disposition=EXTERNAL_LINKS}
are limited to 100 GiB. - The maximum query text size is 16 MiB. -
Cancelation may silently fail. A successful response from a cancel request
indicates that the cancel request was successfully received and sent to the
processing engine. However, for example, an outstanding statement may
complete execution during signal delivery, with the cancel signal arriving
too late to be meaningful. Polling for status until a terminal state is
reached is a reliable way to determine the final state. - Wait timeouts are
approximate, occur server-side, and cannot account for caller delays, network
latency from caller to service, and similarly. - After a statement has been
submitted and a statement_id is returned, that statement's status and result
will automatically close after either of 2 conditions: - The last result
chunk is fetched (or resolved to an external link). - One hour passes with no
calls to get the status or fetch the result. Best practice: in asynchronous
clients, poll for status regularly (and with backoff) to keep the statement
open and alive. - After fetching the last result chunk (including
chunk_index=0) the statement is automatically closed.
}
}
}
\section{Operations}{

\tabular{ll}{
\link[=statement_execution_cancel_execution]{cancel_execution} \tab Cancel statement execution.\cr
\link[=statement_execution_execute_statement]{execute_statement} \tab Execute a SQL statement.\cr
\link[=statement_execution_get_statement]{get_statement} \tab Get status, manifest, and result first chunk.\cr
\link[=statement_execution_get_statement_result_chunk_n]{get_statement_result_chunk_n} \tab Get result chunk by index.\cr
}
}

\keyword{datasets}
